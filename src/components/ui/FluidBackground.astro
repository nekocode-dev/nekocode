---
---
<div id="lava-container">
  <div class="lava-lamp">
    <!-- Blobs will be injected here by JS for randomness -->
  </div>

  <!-- The Gooey Filter -->
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" class="goo-filter">
    <defs>
      <filter id="goo" color-interpolation-filters="sRGB">
        <!-- Blur the shapes -->
        <feGaussianBlur in="SourceGraphic" stdDeviation="12" result="blur" />

        <!-- Threshold to create the gooey shape -->
        <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9" result="goo" />

        <!-- 3D Lighting Effect -->
        <!-- Use the alpha channel of the goo as a height map -->
        <feGaussianBlur in="goo" stdDeviation="2" result="softGoo"/>

        <feSpecularLighting in="softGoo" surfaceScale="6" specularConstant="1.5" specularExponent="25" result="specular" lighting-color="#ffffff">
            <fePointLight x="200" y="-100" z="400"/>
        </feSpecularLighting>

        <!-- Composite the highlight over the goo -->
        <feComposite in="specular" in2="goo" operator="in" result="specularOverGoo"/>
        <feComposite in="SourceGraphic" in2="goo" operator="atop" result="mainShape"/>

        <!-- Blend everything -->
        <feBlend in="mainShape" mode="multiply" result="shaded"/>
        <feBlend in="specularOverGoo" in2="shaded" mode="screen" result="final"/>

        <!-- Fallback for simpler look if blend fails, but usually screen works well for gloss -->
        <feComposite in="specularOverGoo" in2="goo" operator="atop" result="highlight"/>
        <feComposite in="highlight" in2="goo" operator="xor" result="finalShim"/>

        <!-- Simplified: Just put highlight on top of colored goo -->
        <feComposite in="specularOverGoo" in2="goo" operator="atop" result="gloss"/>
        <feComposite in="gloss" in2="goo" operator="over"/>
      </filter>
    </defs>
  </svg>
</div>

<script>
  // Physics Configuration
  const CONFIG = {
    blobCount: 12,
    baseSize: 100,
    sizeVar: 150,
    buoyancy: -0.5, 
    drag: 0.94, // Even thicker
    repulsionRadius: 400,
    repulsionForce: 60, // Reduced significantly
    returnForce: 0.005,
  };

  class BlobEntity {
    constructor(element) {
      this.element = element;
      this.init();
    }

    init(startAtBottom = true) {
      this.size = CONFIG.baseSize + Math.random() * CONFIG.sizeVar;
      this.element.style.width = `${this.size}px`;
      this.element.style.height = `${this.size}px`;
      
      // Random starting position
      this.x = Math.random() * window.innerWidth;
      this.y = startAtBottom 
        ? window.innerHeight + this.size 
        : Math.random() * window.innerHeight;
      
      // Velocity
      this.vx = (Math.random() - 0.5) * 1.5; 
      this.vy = (Math.random() * -1) - 0.5;

      // Animation properties
      const morphDuration = 15 + Math.random() * 15;
      const direction = Math.random() > 0.5 ? 'alternate' : 'alternate-reverse';
      this.element.style.animation = `morph ${morphDuration}s linear infinite ${direction}`;
      
      this.updatePosition();
    }

    update() {
      // Apply forces
      this.vy += -0.02; // Constant buoyancy
      
      // Apply drag
      this.vx *= CONFIG.drag;
      this.vy *= CONFIG.drag;
      
      // Update position
      this.x += this.vx;
      this.y += this.vy;

      // Screen Wrapping/Reset
      if (this.y < -this.size * 2) {
        this.y = window.innerHeight + this.size;
        this.x = Math.random() * window.innerWidth;
        this.vy = (Math.random() * -1) - 0.5;
      }

      if (this.x < -this.size) this.x = window.innerWidth + this.size;
      if (this.x > window.innerWidth + this.size) this.x = -this.size;

      this.updatePosition();
    }

    repel(targetX, targetY) {
      const dx = this.x + this.size/2 - targetX;
      const dy = this.y + this.size/2 - targetY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance < CONFIG.repulsionRadius) {
        // Normalize distance (0 to 1)
        const t = distance / CONFIG.repulsionRadius;
        
        // Quadratic easing (Ease-Out) for gentle push
        // Force is strong at center but drops off smoothly
        const forceFactor = Math.pow(1 - t, 2);
        
        // Soft cap max force to prevent explosive velocity
        // REDUCED CAP from 5 to 1.5 for VERY gentle push
        const force = Math.min(forceFactor * CONFIG.repulsionForce, 1.5);
        
        // Apply direction
        // We use distance + 1 to avoid divide by zero, though unlikely with radius check
        const dirX = dx / (distance || 1);
        const dirY = dy / (distance || 1);
        
        this.vx += dirX * force;
        this.vy += dirY * force;
      }
    }

    updatePosition() {
      // Use efficient transform
      this.element.style.transform = `translate3d(${this.x}px, ${this.y}px, 0)`;
    }
  }

  // Setup
  const container = document.querySelector('.lava-lamp');
  const blobs = [];

  if (container) {
    // Clear existing static blobs potentially added by other scripts
    container.innerHTML = '';

    for(let i=0; i<CONFIG.blobCount; i++) {
        const div = document.createElement('div');
        div.classList.add('blob');
        container.appendChild(div);
        
        // Initialize some randomly on screen, some at bottom
        const blob = new BlobEntity(div);
        if (i < CONFIG.blobCount / 2) {
             blob.y = Math.random() * window.innerHeight; // Start some on screen
        }
        blobs.push(blob);
    }

    // Animation Loop
    function loop() {
      blobs.forEach(blob => blob.update());
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Interaction Handler
    function handleInteraction(x, y) {
      blobs.forEach(blob => blob.repel(x, y));
    }

    window.addEventListener('click', (e) => {
      handleInteraction(e.clientX, e.clientY);
    });

    // Optional: Also repel on mouse move if mouse is down (dragging effect)
    let isMouseDown = false;
    window.addEventListener('mousedown', () => isMouseDown = true);
    window.addEventListener('mouseup', () => isMouseDown = false);
    window.addEventListener('mousemove', (e) => {
      if (isMouseDown) {
         handleInteraction(e.clientX, e.clientY);
      }
    });
  }
</script>

<style>
  #lava-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -10;
    /* Premium "Deep Space Magma" Background */
    background: radial-gradient(circle at 50% 120%, #2b0f42 0%, #050511 60%, #000000 100%);
    overflow: hidden;
    /* Optimization: Create a new stacking context and isolate repaints */
    isolation: isolate;
    contain: paint;
  }

  .lava-lamp {
    width: 100%;
    height: 100%;
    /* Apply custom filter with 3D lighting */
    filter: url('#goo');
    position: absolute;
    top: 0;
    left: 0;
    /* Optimization: Force GPU layer */
    transform: translate3d(0, 0, 0);
    will-change: filter;
  }

  /* Global styles for dynamic blobs */
  :global(.blob) {
    position: absolute;
    /* Golden Magma Gradient - works well with specular highlights */
    background: linear-gradient(180deg, #ff9068 0%, #ff4b4b 60%, #900d2f 100%);
    border-radius: 50%;
    
    /* Default position off-screen, handled by JS */
    top: 0;
    left: 0; 
    
    /* Optimization: Reduce paint cost on movement */
    will-change: transform;
    backface-visibility: hidden;

    /* Box shadow for internal glow before filtering */
    box-shadow: inset 0 0 40px rgba(255, 230, 0, 0.3);
  }

  /* Rise Animation: REMOVED - Handled by JS */

  /* Morph Animation: Handles Organic Shape Wobble */
  :global(@keyframes morph) {
    0% { border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; }
    33% { border-radius: 40% 60% 70% 30% / 50% 60% 30% 60%; }
    66% { border-radius: 50% 50% 30% 70% / 60% 30% 70% 40%; }
    100% { border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; }
  }

  .goo-filter {
    visibility: hidden;
    position: absolute;
    width: 0;
    height: 0;
  }
</style>
