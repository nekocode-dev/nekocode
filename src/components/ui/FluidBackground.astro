---
---
<div id="lava-container">
  <div class="lava-lamp">
    <!-- Blobs will be injected here by JS for randomness -->
  </div>

  <!-- The Gooey Filter -->
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" class="goo-filter">
    <defs>
      <filter id="goo" color-interpolation-filters="sRGB">
        <!-- Blur the shapes -->
        <feGaussianBlur in="SourceGraphic" stdDeviation="12" result="blur" />

        <!-- Threshold to create the gooey shape -->
        <!-- Alpha threshold reduced (19 -> 18) to allow slightly more merging -->
        <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7" result="goo" />

        <!-- 3D Lighting Effect -->
        <!-- Use the alpha channel of the goo as a height map -->
        <feGaussianBlur in="goo" stdDeviation="2" result="softGoo"/>

        <!-- Zen Lighting: Warmer, softer, more "premium oil" feel -->
        <!-- specularConstant reduced (1.0 -> 0.7) for subtler gloss -->
        <!-- specularExponent increased (35 -> 50) for smaller, sharper highlights -->
        <feSpecularLighting in="softGoo" surfaceScale="6" specularConstant="0.7" specularExponent="50" result="specular" lighting-color="#fffff0">
            <fePointLight id="ambient-light" x="200" y="-100" z="500"/>
        </feSpecularLighting>

        <!-- Composite the highlight over the goo -->
        <feComposite in="specular" in2="goo" operator="in" result="specularOverGoo"/>
        <feComposite in="SourceGraphic" in2="goo" operator="atop" result="mainShape"/>

        <!-- Blend everything -->
        <feBlend in="mainShape" mode="multiply" result="shaded"/>
        <feBlend in="specularOverGoo" in2="shaded" mode="screen" result="final"/>

        <!-- Fallback for simpler look if blend fails, but usually screen works well for gloss -->
        <feComposite in="specularOverGoo" in2="goo" operator="atop" result="highlight"/>
        <feComposite in="highlight" in2="goo" operator="xor" result="finalShim"/>

        <!-- Simplified: Just put highlight on top of colored goo -->
        <feComposite in="specularOverGoo" in2="goo" operator="atop" result="gloss"/>
        <feComposite in="gloss" in2="goo" operator="over"/>
      </filter>
    </defs>
  </svg>
</div>

<script>
  /**
   * Realistic Liquid Physics Engine
   * Uses Lennard-Jones Potential for cohesive particle interaction.
   * Simulates Van der Waals forces: Attraction at range, Repulsion at close quarters.
   */
  
  const CONFIG = {
    blobCount: 15, 
    baseRadius: 40, // Much smaller base
    radiusVar: 100, // Massive variance (tiny to huge blobs)
    
    // Lennard-Jones Constants
    epsilon: 0.1, 
    sigmaScale: 2.2, 
    
    // Environment
    gravity: 0.012, // Slight bump up (was 0.008)
    friction: 0.96,
    wallBounce: 0.5,
    
    // Zen Mode Interaction
    // Increased push slightly (0.05 -> 0.2) based on user feedback "too low"
    mouseRepulsion: 0.2, 
    mouseRange: 250,
    
    // Temperature
    temperature: 0.015, // Slight bump up
  };

  class Particle {
    constructor(element, x, y) {
      this.el = element;
      this.pos = { x, y };
      this.vel = { x: (Math.random() - 0.5) * 0.5, y: (Math.random() - 0.5) * 0.5 };
      this.acc = { x: 0, y: 0 };
      this.radius = CONFIG.baseRadius + Math.random() * CONFIG.radiusVar;
      
      // Randomize speed: "Goldilocks" Zone
      // Range: 0.3x (slow) to 0.8x (gentle drift). 
      this.speedFactor = 0.3 + Math.random() * 0.5; 
      
      this.el.style.width = `${this.radius * 2}px`;
      this.el.style.height = `${this.radius * 2}px`;
      
      const duration = 20 + Math.random() * 15;
      const direction = Math.random() > 0.5 ? 'alternate' : 'alternate-reverse';
      this.el.style.animation = `morph ${duration}s linear infinite ${direction}`;
      this.el.style.animationDelay = `-${Math.random() * 20}s`;
    }

    applyForce(fx, fy) {
      this.acc.x += fx;
      this.acc.y += fy;
    }

    update() {
      // 1. Environment Forces
      const buoyancyInfo = (this.radius / CONFIG.baseRadius); 
      // Apply random speed factor to gravity
      this.applyForce(0, -CONFIG.gravity * buoyancyInfo * this.speedFactor);
      
      this.applyForce(
        (Math.random() - 0.5) * CONFIG.temperature * this.speedFactor, 
        (Math.random() - 0.5) * CONFIG.temperature * this.speedFactor
      );

      // 2. Integration
      this.vel.x += this.acc.x;
      this.vel.y += this.acc.y;
      
      this.vel.x *= CONFIG.friction;
      this.vel.y *= CONFIG.friction;
      
      this.pos.x += this.vel.x;
      this.pos.y += this.vel.y;
      
      this.acc.x = 0;
      this.acc.y = 0;

      // 3. Constraints
      this.checkWalls();
      this.updateDOM();
    }

    checkWalls() {
      if (this.pos.y < -this.radius * 2) {
        this.pos.y = windowDimensions.height + this.radius;
        this.vel.y *= 0.2;
        this.pos.x = Math.random() * windowDimensions.width;
      } 
      else if (this.pos.y > windowDimensions.height + this.radius * 2) {
          this.pos.y = -this.radius;
      }

      if (this.pos.x < 0) {
        this.pos.x = 0;
        this.vel.x *= -CONFIG.wallBounce;
      } else if (this.pos.x > windowDimensions.width) {
        this.pos.x = windowDimensions.width;
        this.vel.x *= -CONFIG.wallBounce;
      }
    }

    updateDOM() {
      // Revert: User reported rotation feels unrealistic.
      // Removed velocity-based squash & stretch (rotation/scale).
      // Just use simple position translation for proper liquid feel.
      const transform = `translate3d(${this.pos.x - this.radius}px, ${this.pos.y - this.radius}px, 0)`;
      this.el.style.transform = transform;
    }
  }

  // --- Physics System ---
  
  let particles = [];
  let connectionState = { 
      mouseX: window.innerWidth/2, 
      mouseY: window.innerHeight/2, 
      isMouseDown: false 
  };
  
  // High-Fidelity: Lighting Smoothing State
  let lightPos = { x: window.innerWidth/2, y: window.innerHeight/2 };
  
  let windowDimensions = { width: window.innerWidth, height: window.innerHeight };

  window.addEventListener('resize', () => {
    windowDimensions = { width: window.innerWidth, height: window.innerHeight };
  });

  window.addEventListener('mousemove', (e) => {
    connectionState.mouseX = e.clientX;
    connectionState.mouseY = e.clientY;
    
    // High-Fidelity: Dynamic Lighting
    // Update the SVG light source to follow the mouse
    const light = document.querySelector('#ambient-light');
    if (light) {
        // slight lag/smoothing or direct verify? Direct is punchier for UI.
        light.setAttribute('x', e.clientX);
        light.setAttribute('y', e.clientY);
    }
  });
  
  window.addEventListener('mousedown', () => connectionState.isMouseDown = true);
  window.addEventListener('mouseup', () => connectionState.isMouseDown = false);

  function init() {
    const container = document.querySelector('.lava-lamp');
    if (!container) return;
    
    container.innerHTML = '';
    particles = [];

    for (let i = 0; i < CONFIG.blobCount; i++) {
      const div = document.createElement('div');
      div.classList.add('blob');
      container.appendChild(div);
      
      const x = Math.random() * windowDimensions.width;
      const y = Math.random() * windowDimensions.height;
      
      particles.push(new Particle(div, x, y));
    }
    
    loop();
  }

  function interact() {
    const { mouseX, mouseY } = connectionState;

    for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const dx = p.pos.x - mouseX;
        const dy = p.pos.y - mouseY;
        const distSq = dx*dx + dy*dy;
        
        if (distSq < CONFIG.mouseRange * CONFIG.mouseRange && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const force = (1 - dist / CONFIG.mouseRange) * CONFIG.mouseRepulsion;
            p.applyForce((dx/dist) * force, (dy/dist) * force);
        }
    }
  }

  function computeCohesion() {
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const p1 = particles[i];
        const p2 = particles[j];
        
        const dx = p2.pos.x - p1.pos.x;
        const dy = p2.pos.y - p1.pos.y;
        const distSq = dx*dx + dy*dy;
        
        // Effective "Merge" Radius
        // Sigma is where the force is zero. We want them to overlap.
        const sigma = (p1.radius + p2.radius) * 0.65; // Overlap factor (0.65 = deep merge)
        const cutoff = sigma * 3; 
        
        if (distSq > cutoff * cutoff || distSq === 0) continue;
        
        const r = Math.sqrt(distSq);
        const rNorm = r / sigma; 
        
        let force = 0;
        
        // Custom Potential for "Sticky Liquid"
        if (rNorm < 0.8) {
             // Repel only when VERY close (prevent explosion)
             force = -1.0 * (0.8 - rNorm); 
        } else if (rNorm < 1.5) {
             // Strong Attraction (Cohesion/Surface Tension) in the middle
             // This pulls them into a "single big blob"
             force = 0.15 * (1.5 - rNorm); 
        } else {
             // Weak Gravity pull at distance
             force = 0.02 * (3.0 - rNorm);
        }
        
        const fx = (dx / r) * force * CONFIG.epsilon;
        const fy = (dy / r) * force * CONFIG.epsilon;
        
        p1.applyForce(fx, fy);
        p2.applyForce(-fx, -fy);
      }
    }
  }

  function updateLighting() {
      // Smoothly interpolate light position towards mouse (The "Lantern" effect)
      // Factor 0.08 = slow fluid lag. Feels like dragging a heavy light through water.
      lightPos.x += (connectionState.mouseX - lightPos.x) * 0.08;
      lightPos.y += (connectionState.mouseY - lightPos.y) * 0.08;

      const light = document.querySelector('#ambient-light');
      if (light) {
          light.setAttribute('x', lightPos.x);
          light.setAttribute('y', lightPos.y);
      }
  }

  function loop() {
    interact();
    computeCohesion();
    updateLighting(); // Apply smoothed lighting
    
    for (const p of particles) {
      p.update();
    }
    
    requestAnimationFrame(loop);
  }

  setTimeout(init, 100);

</script>

<style>
  #lava-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -10;
    /* Premium "Deep Space Magma" Background */
    background: radial-gradient(circle at 50% 120%, #2b0f42 0%, #050511 60%, #000000 100%);
    overflow: hidden;
    /* Optimization: Create a new stacking context and isolate repaints */
    isolation: isolate;
    contain: paint;
  }

  .lava-lamp {
    width: 100%;
    height: 100%;
    /* Apply custom filter with 3D lighting */
    filter: url('#goo');
    position: absolute;
    top: 0;
    left: 0;
    /* Optimization: Force GPU layer */
    transform: translate3d(0, 0, 0);
    will-change: filter;
  }

  /* Global styles for dynamic blobs */
  :global(.blob) {
    position: absolute;
    /* Golden Magma Gradient - works well with specular highlights */
    background: linear-gradient(180deg, #ff9068 0%, #ff4b4b 60%, #900d2f 100%);
    border-radius: 50%;
    
    /* Default position off-screen, handled by JS */
    top: 0;
    left: 0; 
    
    /* Optimization: Reduce paint cost on movement */
    will-change: transform;
    backface-visibility: hidden;

    /* Box shadow for internal glow before filtering */
    box-shadow: inset 0 0 40px rgba(255, 230, 0, 0.3);
  }

  /* Rise Animation: REMOVED - Handled by JS */

  /* Morph Animation: Handles Organic Shape Wobble */
  /* Morph Animation: Handles Organic Shape Wobble - EXAGGERATED for visible "wave" */
  :global(@keyframes morph) {
    0% { border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; }
    25% { border-radius: 45% 55% 20% 80% / 55% 25% 75% 45%; }
    50% { border-radius: 20% 80% 60% 40% / 30% 70% 20% 80%; }
    75% { border-radius: 70% 30% 80% 20% / 70% 30% 20% 80%; }
    100% { border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; }
  }

  .goo-filter {
    visibility: hidden;
    position: absolute;
    width: 0;
    height: 0;
  }
</style>
